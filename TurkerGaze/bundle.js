/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2);

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(3)(__webpack_require__(4))

/***/ },
/* 3 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		if (typeof execScript === "function")
			execScript(src);
		else
			eval.call(null, src);
	}

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = "// WebcamJS v1.0.6\n// Webcam library for capturing JPEG/PNG images in JavaScript\n// Attempts getUserMedia, falls back to Flash\n// Author: Joseph Huckaby: http://github.com/jhuckaby\n// Based on JPEGCam: http://code.google.com/p/jpegcam/\n// Copyright (c) 2012 - 2015 Joseph Huckaby\n// Licensed under the MIT License\n\n(function(window) {\n\nvar Webcam = {\n\tversion: '1.0.6',\n\t\n\t// globals\n\tprotocol: location.protocol.match(/https/i) ? 'https' : 'http',\n\tswfURL: '',      // URI to webcam.swf movie (defaults to the js location)\n\tloaded: false,   // true when webcam movie finishes loading\n\tlive: false,     // true when webcam is initialized and ready to snap\n\tuserMedia: true, // true when getUserMedia is supported natively\n\t\n\tparams: {\n\t\twidth: 0,\n\t\theight: 0,\n\t\tdest_width: 0,         // size of captured image\n\t\tdest_height: 0,        // these default to width/height\n\t\timage_format: 'jpeg',  // image format (may be jpeg or png)\n\t\tjpeg_quality: 90,      // jpeg image quality from 0 (worst) to 100 (best)\n\t\tforce_flash: false,    // force flash mode,\n\t\tflip_horiz: false,     // flip image horiz (mirror mode)\n\t\tfps: 30,               // camera frames per second\n\t\tupload_name: 'webcam', // name of file in upload post data\n\t\tconstraints: null      // custom user media constraints\n\t},\n\t\n\thooks: {}, // callback hook functions\n\t\n\tinit: function() {\n\t\t// initialize, check for getUserMedia support\n\t\tvar self = this;\n\t\t\n\t\t// Setup getUserMedia, with polyfill for older browsers\n\t\t// Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n\t\tthis.mediaDevices = (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ? \n\t\t\tnavigator.mediaDevices : ((navigator.mozGetUserMedia || navigator.webkitGetUserMedia) ? {\n\t\t\t\tgetUserMedia: function(c) {\n\t\t\t\t\treturn new Promise(function(y, n) {\n\t\t\t\t\t\t(navigator.mozGetUserMedia ||\n\t\t\t\t\t\tnavigator.webkitGetUserMedia).call(navigator, c, y, n);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t} : null);\n\t\t\n\t\twindow.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\t\tthis.userMedia = this.userMedia && !!this.mediaDevices && !!window.URL;\n\t\t\n\t\t// Older versions of firefox (< 21) apparently claim support but user media does not actually work\n\t\tif (navigator.userAgent.match(/Firefox\\D+(\\d+)/)) {\n\t\t\tif (parseInt(RegExp.$1, 10) < 21) this.userMedia = null;\n\t\t}\n\t\t\n\t\t// Make sure media stream is closed when navigating away from page\n\t\tif (this.userMedia) {\n\t\t\twindow.addEventListener( 'beforeunload', function(event) {\n\t\t\t\tself.reset();\n\t\t\t} );\n\t\t}\n\t},\n\t\n\tattach: function(elem) {\n\t\t// create webcam preview and attach to DOM element\n\t\t// pass in actual DOM reference, ID, or CSS selector\n\t\tif (typeof(elem) == 'string') {\n\t\t\telem = document.getElementById(elem) || document.querySelector(elem);\n\t\t}\n\t\tif (!elem) {\n\t\t\treturn this.dispatch('error', \"Could not locate DOM element to attach to.\");\n\t\t}\n\t\tthis.container = elem;\n\t\telem.innerHTML = ''; // start with empty element\n\t\t\n\t\t// insert \"peg\" so we can insert our preview canvas adjacent to it later on\n\t\tvar peg = document.createElement('div');\n\t\telem.appendChild( peg );\n\t\tthis.peg = peg;\n\t\t\n\t\t// set width/height if not already set\n\t\tif (!this.params.width) this.params.width = elem.offsetWidth;\n\t\tif (!this.params.height) this.params.height = elem.offsetHeight;\n\t\t\n\t\t// set defaults for dest_width / dest_height if not set\n\t\tif (!this.params.dest_width) this.params.dest_width = this.params.width;\n\t\tif (!this.params.dest_height) this.params.dest_height = this.params.height;\n\t\t\n\t\t// if force_flash is set, disable userMedia\n\t\tif (this.params.force_flash) this.userMedia = null;\n\t\t\n\t\t// check for default fps\n\t\tif (typeof this.params.fps !== \"number\") this.params.fps = 30;\n\n\t\t// adjust scale if dest_width or dest_height is different\n\t\tvar scaleX = this.params.width / this.params.dest_width;\n\t\tvar scaleY = this.params.height / this.params.dest_height;\n\t\t\n\t\tif (this.userMedia) {\n\t\t\t// setup webcam video container\n\t\t\tvar video = document.createElement('video');\n\t\t\tvideo.setAttribute('autoplay', 'autoplay');\n\t\t\tvideo.style.width = '' + this.params.dest_width + 'px';\n\t\t\tvideo.style.height = '' + this.params.dest_height + 'px';\n\t\t\t\n\t\t\tif ((scaleX != 1.0) || (scaleY != 1.0)) {\n\t\t\t\telem.style.overflow = 'hidden';\n\t\t\t\tvideo.style.webkitTransformOrigin = '0px 0px';\n\t\t\t\tvideo.style.mozTransformOrigin = '0px 0px';\n\t\t\t\tvideo.style.msTransformOrigin = '0px 0px';\n\t\t\t\tvideo.style.oTransformOrigin = '0px 0px';\n\t\t\t\tvideo.style.transformOrigin = '0px 0px';\n\t\t\t\tvideo.style.webkitTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';\n\t\t\t\tvideo.style.mozTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';\n\t\t\t\tvideo.style.msTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';\n\t\t\t\tvideo.style.oTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';\n\t\t\t\tvideo.style.transform = 'scaleX('+scaleX+') scaleY('+scaleY+')';\n\t\t\t}\n\t\t\t\n\t\t\t// add video element to dom\n\t\t\telem.appendChild( video );\n\t\t\tthis.video = video;\n\t\t\t\n\t\t\t// ask user for access to their camera\n\t\t\tvar self = this;\n\t\t\tthis.mediaDevices.getUserMedia({\n\t\t\t\t\"audio\": false,\n\t\t\t\t\"video\": this.params.constraints || {\n\t\t\t\t\tmandatory: {\n\t\t\t\t\t\tminWidth: this.params.dest_width,\n\t\t\t\t\t\tminHeight: this.params.dest_height\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then( function(stream) {\n\t\t\t\t// got access, attach stream to video\n\t\t\t\tvideo.src = window.URL.createObjectURL( stream ) || stream;\n\t\t\t\tself.stream = stream;\n\t\t\t\tself.loaded = true;\n\t\t\t\tself.live = true;\n\t\t\t\tself.dispatch('load');\n\t\t\t\tself.dispatch('live');\n\t\t\t\tself.flip();\n\t\t\t})\n\t\t\t.catch( function(err) {\n\t\t\t\treturn self.dispatch('error', \"Could not access webcam: \" + err.name + \": \" + err.message, err);\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\t// flash fallback\n\t\t\twindow.Webcam = Webcam; // needed for flash-to-js interface\n\t\t\tvar div = document.createElement('div');\n\t\t\tdiv.innerHTML = this.getSWFHTML();\n\t\t\telem.appendChild( div );\n\t\t}\n\t\t\n\t\t// setup final crop for live preview\n\t\tif (this.params.crop_width && this.params.crop_height) {\n\t\t\tvar scaled_crop_width = Math.floor( this.params.crop_width * scaleX );\n\t\t\tvar scaled_crop_height = Math.floor( this.params.crop_height * scaleY );\n\t\t\t\n\t\t\telem.style.width = '' + scaled_crop_width + 'px';\n\t\t\telem.style.height = '' + scaled_crop_height + 'px';\n\t\t\telem.style.overflow = 'hidden';\n\t\t\t\n\t\t\telem.scrollLeft = Math.floor( (this.params.width / 2) - (scaled_crop_width / 2) );\n\t\t\telem.scrollTop = Math.floor( (this.params.height / 2) - (scaled_crop_height / 2) );\n\t\t}\n\t\telse {\n\t\t\t// no crop, set size to desired\n\t\t\telem.style.width = '' + this.params.width + 'px';\n\t\t\telem.style.height = '' + this.params.height + 'px';\n\t\t}\n\t},\n\t\n\treset: function() {\n\t\t// shutdown camera, reset to potentially attach again\n\t\tif (this.preview_active) this.unfreeze();\n\t\t\n\t\t// attempt to fix issue #64\n\t\tthis.unflip();\n\t\t\n\t\tif (this.userMedia) {\n\t\t\tif (this.stream) {\n\t\t\t\tif (this.stream.getVideoTracks) {\n\t\t\t\t\t// get video track to call stop on it\n\t\t\t\t\tvar tracks = this.stream.getVideoTracks();\n\t\t\t\t\tif (tracks && tracks[0] && tracks[0].stop) tracks[0].stop();\n\t\t\t\t}\n\t\t\t\telse if (this.stream.stop) {\n\t\t\t\t\t// deprecated, may be removed in future\n\t\t\t\t\tthis.stream.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete this.stream;\n\t\t\tdelete this.video;\n\t\t}\n\t\t\n\t\tif (this.container) {\n\t\t\tthis.container.innerHTML = '';\n\t\t\tdelete this.container;\n\t\t}\n\t\n\t\tthis.loaded = false;\n\t\tthis.live = false;\n\t},\n\t\n\tset: function() {\n\t\t// set one or more params\n\t\t// variable argument list: 1 param = hash, 2 params = key, value\n\t\tif (arguments.length == 1) {\n\t\t\tfor (var key in arguments[0]) {\n\t\t\t\tthis.params[key] = arguments[0][key];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.params[ arguments[0] ] = arguments[1];\n\t\t}\n\t},\n\t\n\ton: function(name, callback) {\n\t\t// set callback hook\n\t\tname = name.replace(/^on/i, '').toLowerCase();\n\t\tif (!this.hooks[name]) this.hooks[name] = [];\n\t\tthis.hooks[name].push( callback );\n\t},\n\t\n\toff: function(name, callback) {\n\t\t// remove callback hook\n\t\tname = name.replace(/^on/i, '').toLowerCase();\n\t\tif (this.hooks[name]) {\n\t\t\tif (callback) {\n\t\t\t\t// remove one selected callback from list\n\t\t\t\tvar idx = this.hooks[name].indexOf(callback);\n\t\t\t\tif (idx > -1) this.hooks[name].splice(idx, 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// no callback specified, so clear all\n\t\t\t\tthis.hooks[name] = [];\n\t\t\t}\n\t\t}\n\t},\n\t\n\tdispatch: function() {\n\t\t// fire hook callback, passing optional value to it\n\t\tvar name = arguments[0].replace(/^on/i, '').toLowerCase();\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\t\t\n\t\tif (this.hooks[name] && this.hooks[name].length) {\n\t\t\tfor (var idx = 0, len = this.hooks[name].length; idx < len; idx++) {\n\t\t\t\tvar hook = this.hooks[name][idx];\n\t\t\t\t\n\t\t\t\tif (typeof(hook) == 'function') {\n\t\t\t\t\t// callback is function reference, call directly\n\t\t\t\t\thook.apply(this, args);\n\t\t\t\t}\n\t\t\t\telse if ((typeof(hook) == 'object') && (hook.length == 2)) {\n\t\t\t\t\t// callback is PHP-style object instance method\n\t\t\t\t\thook[0][hook[1]].apply(hook[0], args);\n\t\t\t\t}\n\t\t\t\telse if (window[hook]) {\n\t\t\t\t\t// callback is global function name\n\t\t\t\t\twindow[ hook ].apply(window, args);\n\t\t\t\t}\n\t\t\t} // loop\n\t\t\treturn true;\n\t\t}\n\t\telse if (name == 'error') {\n\t\t\t// default error handler if no custom one specified\n\t\t\talert(\"Webcam.js Error: \" + args[0]);\n\t\t}\n\t\t\n\t\treturn false; // no hook defined\n\t},\n\t\n\tsetSWFLocation: function(url) {\n\t\t// set location of SWF movie (defaults to webcam.swf in cwd)\n\t\tthis.swfURL = url;\n\t},\n\t\n\tdetectFlash: function() {\n\t\t// return true if browser supports flash, false otherwise\n\t\t// Code snippet borrowed from: https://github.com/swfobject/swfobject\n\t\tvar SHOCKWAVE_FLASH = \"Shockwave Flash\",\n\t\t\tSHOCKWAVE_FLASH_AX = \"ShockwaveFlash.ShockwaveFlash\",\n        \tFLASH_MIME_TYPE = \"application/x-shockwave-flash\",\n        \twin = window,\n        \tnav = navigator,\n        \thasFlash = false;\n        \n        if (typeof nav.plugins !== \"undefined\" && typeof nav.plugins[SHOCKWAVE_FLASH] === \"object\") {\n        \tvar desc = nav.plugins[SHOCKWAVE_FLASH].description;\n        \tif (desc && (typeof nav.mimeTypes !== \"undefined\" && nav.mimeTypes[FLASH_MIME_TYPE] && nav.mimeTypes[FLASH_MIME_TYPE].enabledPlugin)) {\n        \t\thasFlash = true;\n        \t}\n        }\n        else if (typeof win.ActiveXObject !== \"undefined\") {\n        \ttry {\n        \t\tvar ax = new ActiveXObject(SHOCKWAVE_FLASH_AX);\n        \t\tif (ax) {\n        \t\t\tvar ver = ax.GetVariable(\"$version\");\n        \t\t\tif (ver) hasFlash = true;\n        \t\t}\n        \t}\n        \tcatch (e) {;}\n        }\n        \n        return hasFlash;\n\t},\n\t\n\tgetSWFHTML: function() {\n\t\t// Return HTML for embedding flash based webcam capture movie\t\t\n\t\tvar html = '';\n\t\t\n\t\t// make sure we aren't running locally (flash doesn't work)\n\t\tif (location.protocol.match(/file/)) {\n\t\t\tthis.dispatch('error', \"Flash does not work from local disk.  Please run from a web server.\");\n\t\t\treturn '<h3 style=\"color:red\">ERROR: the Webcam.js Flash fallback does not work from local disk.  Please run it from a web server.</h3>';\n\t\t}\n\t\t\n\t\t// make sure we have flash\n\t\tif (!this.detectFlash()) {\n\t\t\tthis.dispatch('error', \"Adobe Flash Player not found.  Please install from get.adobe.com/flashplayer and try again.\");\n\t\t\treturn '<h3 style=\"color:red\">ERROR: No Adobe Flash Player detected.  Webcam.js relies on Flash for browsers that do not support getUserMedia (like yours).</h3>';\n\t\t}\n\t\t\n\t\t// set default swfURL if not explicitly set\n\t\tif (!this.swfURL) {\n\t\t\t// find our script tag, and use that base URL\n\t\t\tvar base_url = '';\n\t\t\tvar scpts = document.getElementsByTagName('script');\n\t\t\tfor (var idx = 0, len = scpts.length; idx < len; idx++) {\n\t\t\t\tvar src = scpts[idx].getAttribute('src');\n\t\t\t\tif (src && src.match(/\\/webcam(\\.min)?\\.js/)) {\n\t\t\t\t\tbase_url = src.replace(/\\/webcam(\\.min)?\\.js.*$/, '');\n\t\t\t\t\tidx = len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (base_url) this.swfURL = base_url + '/webcam.swf';\n\t\t\telse this.swfURL = 'webcam.swf';\n\t\t}\n\t\t\n\t\t// if this is the user's first visit, set flashvar so flash privacy settings panel is shown first\n\t\tif (window.localStorage && !localStorage.getItem('visited')) {\n\t\t\tthis.params.new_user = 1;\n\t\t\tlocalStorage.setItem('visited', 1);\n\t\t}\n\t\t\n\t\t// construct flashvars string\n\t\tvar flashvars = '';\n\t\tfor (var key in this.params) {\n\t\t\tif (flashvars) flashvars += '&';\n\t\t\tflashvars += key + '=' + escape(this.params[key]);\n\t\t}\n\t\t\n\t\t// construct object/embed tag\n\t\thtml += '<object classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" type=\"application/x-shockwave-flash\" codebase=\"'+this.protocol+'://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0\" width=\"'+this.params.width+'\" height=\"'+this.params.height+'\" id=\"webcam_movie_obj\" align=\"middle\"><param name=\"wmode\" value=\"opaque\" /><param name=\"allowScriptAccess\" value=\"always\" /><param name=\"allowFullScreen\" value=\"false\" /><param name=\"movie\" value=\"'+this.swfURL+'\" /><param name=\"loop\" value=\"false\" /><param name=\"menu\" value=\"false\" /><param name=\"quality\" value=\"best\" /><param name=\"bgcolor\" value=\"#ffffff\" /><param name=\"flashvars\" value=\"'+flashvars+'\"/><embed id=\"webcam_movie_embed\" src=\"'+this.swfURL+'\" wmode=\"opaque\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" width=\"'+this.params.width+'\" height=\"'+this.params.height+'\" name=\"webcam_movie_embed\" align=\"middle\" allowScriptAccess=\"always\" allowFullScreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"'+flashvars+'\"></embed></object>';\n\t\t\n\t\treturn html;\n\t},\n\t\n\tgetMovie: function() {\n\t\t// get reference to movie object/embed in DOM\n\t\tif (!this.loaded) return this.dispatch('error', \"Flash Movie is not loaded yet\");\n\t\tvar movie = document.getElementById('webcam_movie_obj');\n\t\tif (!movie || !movie._snap) movie = document.getElementById('webcam_movie_embed');\n\t\tif (!movie) this.dispatch('error', \"Cannot locate Flash movie in DOM\");\n\t\treturn movie;\n\t},\n\t\n\tfreeze: function() {\n\t\t// show preview, freeze camera\n\t\tvar self = this;\n\t\tvar params = this.params;\n\t\t\n\t\t// kill preview if already active\n\t\tif (this.preview_active) this.unfreeze();\n\t\t\n\t\t// determine scale factor\n\t\tvar scaleX = this.params.width / this.params.dest_width;\n\t\tvar scaleY = this.params.height / this.params.dest_height;\n\t\t\n\t\t// must unflip container as preview canvas will be pre-flipped\n\t\tthis.unflip();\n\t\t\n\t\t// calc final size of image\n\t\tvar final_width = params.crop_width || params.dest_width;\n\t\tvar final_height = params.crop_height || params.dest_height;\n\t\t\n\t\t// create canvas for holding preview\n\t\tvar preview_canvas = document.createElement('canvas');\n\t\tpreview_canvas.width = final_width;\n\t\tpreview_canvas.height = final_height;\n\t\tvar preview_context = preview_canvas.getContext('2d');\n\t\t\n\t\t// save for later use\n\t\tthis.preview_canvas = preview_canvas;\n\t\tthis.preview_context = preview_context;\n\t\t\n\t\t// scale for preview size\n\t\tif ((scaleX != 1.0) || (scaleY != 1.0)) {\n\t\t\tpreview_canvas.style.webkitTransformOrigin = '0px 0px';\n\t\t\tpreview_canvas.style.mozTransformOrigin = '0px 0px';\n\t\t\tpreview_canvas.style.msTransformOrigin = '0px 0px';\n\t\t\tpreview_canvas.style.oTransformOrigin = '0px 0px';\n\t\t\tpreview_canvas.style.transformOrigin = '0px 0px';\n\t\t\tpreview_canvas.style.webkitTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';\n\t\t\tpreview_canvas.style.mozTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';\n\t\t\tpreview_canvas.style.msTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';\n\t\t\tpreview_canvas.style.oTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';\n\t\t\tpreview_canvas.style.transform = 'scaleX('+scaleX+') scaleY('+scaleY+')';\n\t\t}\n\t\t\n\t\t// take snapshot, but fire our own callback\n\t\tthis.snap( function() {\n\t\t\t// add preview image to dom, adjust for crop\n\t\t\tpreview_canvas.style.position = 'relative';\n\t\t\tpreview_canvas.style.left = '' + self.container.scrollLeft + 'px';\n\t\t\tpreview_canvas.style.top = '' + self.container.scrollTop + 'px';\n\t\t\t\n\t\t\tself.container.insertBefore( preview_canvas, self.peg );\n\t\t\tself.container.style.overflow = 'hidden';\n\t\t\t\n\t\t\t// set flag for user capture (use preview)\n\t\t\tself.preview_active = true;\n\t\t\t\n\t\t}, preview_canvas );\n\t},\n\t\n\tunfreeze: function() {\n\t\t// cancel preview and resume live video feed\n\t\tif (this.preview_active) {\n\t\t\t// remove preview canvas\n\t\t\tthis.container.removeChild( this.preview_canvas );\n\t\t\tdelete this.preview_context;\n\t\t\tdelete this.preview_canvas;\n\t\t\t\n\t\t\t// unflag\n\t\t\tthis.preview_active = false;\n\t\t\t\n\t\t\t// re-flip if we unflipped before\n\t\t\tthis.flip();\n\t\t}\n\t},\n\t\n\tflip: function() {\n\t\t// flip container horiz (mirror mode) if desired\n\t\tif (this.params.flip_horiz) {\n\t\t\tvar sty = this.container.style;\n\t\t\tsty.webkitTransform = 'scaleX(-1)';\n\t\t\tsty.mozTransform = 'scaleX(-1)';\n\t\t\tsty.msTransform = 'scaleX(-1)';\n\t\t\tsty.oTransform = 'scaleX(-1)';\n\t\t\tsty.transform = 'scaleX(-1)';\n\t\t\tsty.filter = 'FlipH';\n\t\t\tsty.msFilter = 'FlipH';\n\t\t}\n\t},\n\t\n\tunflip: function() {\n\t\t// unflip container horiz (mirror mode) if desired\n\t\tif (this.params.flip_horiz) {\n\t\t\tvar sty = this.container.style;\n\t\t\tsty.webkitTransform = 'scaleX(1)';\n\t\t\tsty.mozTransform = 'scaleX(1)';\n\t\t\tsty.msTransform = 'scaleX(1)';\n\t\t\tsty.oTransform = 'scaleX(1)';\n\t\t\tsty.transform = 'scaleX(1)';\n\t\t\tsty.filter = '';\n\t\t\tsty.msFilter = '';\n\t\t}\n\t},\n\t\n\tsavePreview: function(user_callback, user_canvas) {\n\t\t// save preview freeze and fire user callback\n\t\tvar params = this.params;\n\t\tvar canvas = this.preview_canvas;\n\t\tvar context = this.preview_context;\n\t\t\n\t\t// render to user canvas if desired\n\t\tif (user_canvas) {\n\t\t\tvar user_context = user_canvas.getContext('2d');\n\t\t\tuser_context.drawImage( canvas, 0, 0 );\n\t\t}\n\t\t\n\t\t// fire user callback if desired\n\t\tuser_callback(\n\t\t\tuser_canvas ? null : canvas.toDataURL('image/' + params.image_format, params.jpeg_quality / 100 ),\n\t\t\tcanvas,\n\t\t\tcontext\n\t\t);\n\t\t\n\t\t// remove preview\n\t\tthis.unfreeze();\n\t},\n\t\n\tsnap: function(user_callback, user_canvas) {\n\t\t// take snapshot and return image data uri\n\t\tvar self = this;\n\t\tvar params = this.params;\n\t\t\n\t\tif (!this.loaded) return this.dispatch('error', \"Webcam is not loaded yet\");\n\t\t// if (!this.live) return this.dispatch('error', \"Webcam is not live yet\");\n\t\tif (!user_callback) return this.dispatch('error', \"Please provide a callback function or canvas to snap()\");\n\t\t\n\t\t// if we have an active preview freeze, use that\n\t\tif (this.preview_active) {\n\t\t\tthis.savePreview( user_callback, user_canvas );\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// create offscreen canvas element to hold pixels\n\t\tvar canvas = document.createElement('canvas');\n\t\tcanvas.width = this.params.dest_width;\n\t\tcanvas.height = this.params.dest_height;\n\t\tvar context = canvas.getContext('2d');\n\t\t\n\t\t// flip canvas horizontally if desired\n\t\tif (this.params.flip_horiz) {\n\t\t\tcontext.translate( params.dest_width, 0 );\n\t\t\tcontext.scale( -1, 1 );\n\t\t}\n\t\t\n\t\t// create inline function, called after image load (flash) or immediately (native)\n\t\tvar func = function() {\n\t\t\t// render image if needed (flash)\n\t\t\tif (this.src && this.width && this.height) {\n\t\t\t\tcontext.drawImage(this, 0, 0, params.dest_width, params.dest_height);\n\t\t\t}\n\t\t\t\n\t\t\t// crop if desired\n\t\t\tif (params.crop_width && params.crop_height) {\n\t\t\t\tvar crop_canvas = document.createElement('canvas');\n\t\t\t\tcrop_canvas.width = params.crop_width;\n\t\t\t\tcrop_canvas.height = params.crop_height;\n\t\t\t\tvar crop_context = crop_canvas.getContext('2d');\n\t\t\t\t\n\t\t\t\tcrop_context.drawImage( canvas, \n\t\t\t\t\tMath.floor( (params.dest_width / 2) - (params.crop_width / 2) ),\n\t\t\t\t\tMath.floor( (params.dest_height / 2) - (params.crop_height / 2) ),\n\t\t\t\t\tparams.crop_width,\n\t\t\t\t\tparams.crop_height,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tparams.crop_width,\n\t\t\t\t\tparams.crop_height\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\t// swap canvases\n\t\t\t\tcontext = crop_context;\n\t\t\t\tcanvas = crop_canvas;\n\t\t\t}\n\t\t\t\n\t\t\t// render to user canvas if desired\n\t\t\tif (user_canvas) {\n\t\t\t\tvar user_context = user_canvas.getContext('2d');\n\t\t\t\tuser_context.drawImage( canvas, 0, 0 );\n\t\t\t}\n\t\t\t\n\t\t\t// fire user callback if desired\n\t\t\tuser_callback(\n\t\t\t\tuser_canvas ? null : canvas.toDataURL('image/' + params.image_format, params.jpeg_quality / 100 ),\n\t\t\t\tcanvas,\n\t\t\t\tcontext\n\t\t\t);\n\t\t};\n\t\t\n\t\t// grab image frame from userMedia or flash movie\n\t\tif (this.userMedia) {\n\t\t\t// native implementation\n\t\t\tcontext.drawImage(this.video, 0, 0, this.params.dest_width, this.params.dest_height);\n\t\t\t\n\t\t\t// fire callback right away\n\t\t\tfunc();\n\t\t}\n\t\telse {\n\t\t\t// flash fallback\n\t\t\tvar raw_data = this.getMovie()._snap();\n\t\t\t\n\t\t\t// render to image, fire callback when complete\n\t\t\tvar img = new Image();\n\t\t\timg.onload = func;\n\t\t\timg.src = 'data:image/'+this.params.image_format+';base64,' + raw_data;\n\t\t}\n\t\t\n\t\treturn null;\n\t},\n\t\n\tconfigure: function(panel) {\n\t\t// open flash configuration panel -- specify tab name:\n\t\t// \"camera\", \"privacy\", \"default\", \"localStorage\", \"microphone\", \"settingsManager\"\n\t\tif (!panel) panel = \"camera\";\n\t\tthis.getMovie()._configure(panel);\n\t},\n\t\n\tflashNotify: function(type, msg) {\n\t\t// receive notification from flash about event\n\t\tswitch (type) {\n\t\t\tcase 'flashLoadComplete':\n\t\t\t\t// movie loaded successfully\n\t\t\t\tthis.loaded = true;\n\t\t\t\tthis.dispatch('load');\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase 'cameraLive':\n\t\t\t\t// camera is live and ready to snap\n\t\t\t\tthis.live = true;\n\t\t\t\tthis.dispatch('live');\n\t\t\t\tthis.flip();\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\t// Flash error\n\t\t\t\tthis.dispatch('error', msg);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// catch-all event, just in case\n\t\t\t\t// console.log(\"webcam flash_notify: \" + type + \": \" + msg);\n\t\t\t\tbreak;\n\t\t}\n\t},\n\t\n\tb64ToUint6: function(nChr) {\n\t\t// convert base64 encoded character to 6-bit integer\n\t\t// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding\n\t\treturn nChr > 64 && nChr < 91 ? nChr - 65\n\t\t\t: nChr > 96 && nChr < 123 ? nChr - 71\n\t\t\t: nChr > 47 && nChr < 58 ? nChr + 4\n\t\t\t: nChr === 43 ? 62 : nChr === 47 ? 63 : 0;\n\t},\n\n\tbase64DecToArr: function(sBase64, nBlocksSize) {\n\t\t// convert base64 encoded string to Uintarray\n\t\t// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding\n\t\tvar sB64Enc = sBase64.replace(/[^A-Za-z0-9\\+\\/]/g, \"\"), nInLen = sB64Enc.length,\n\t\t\tnOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, \n\t\t\ttaBytes = new Uint8Array(nOutLen);\n\t\t\n\t\tfor (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n\t\t\tnMod4 = nInIdx & 3;\n\t\t\tnUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;\n\t\t\tif (nMod4 === 3 || nInLen - nInIdx === 1) {\n\t\t\t\tfor (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n\t\t\t\t\ttaBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\n\t\t\t\t}\n\t\t\t\tnUint24 = 0;\n\t\t\t}\n\t\t}\n\t\treturn taBytes;\n\t},\n\t\n\tupload: function(image_data_uri, target_url, callback) {\n\t\t// submit image data to server using binary AJAX\n\t\tvar form_elem_name = this.params.upload_name || 'webcam';\n\t\t\n\t\t// detect image format from within image_data_uri\n\t\tvar image_fmt = '';\n\t\tif (image_data_uri.match(/^data\\:image\\/(\\w+)/))\n\t\t\timage_fmt = RegExp.$1;\n\t\telse\n\t\t\tthrow \"Cannot locate image format in Data URI\";\n\t\t\n\t\t// extract raw base64 data from Data URI\n\t\tvar raw_image_data = image_data_uri.replace(/^data\\:image\\/\\w+\\;base64\\,/, '');\n\t\t\n\t\t// contruct use AJAX object\n\t\tvar http = new XMLHttpRequest();\n\t\thttp.open(\"POST\", target_url, true);\n\t\t\n\t\t// setup progress events\n\t\tif (http.upload && http.upload.addEventListener) {\n\t\t\thttp.upload.addEventListener( 'progress', function(e) {\n\t\t\t\tif (e.lengthComputable) {\n\t\t\t\t\tvar progress = e.loaded / e.total;\n\t\t\t\t\tWebcam.dispatch('uploadProgress', progress, e);\n\t\t\t\t}\n\t\t\t}, false );\n\t\t}\n\t\t\n\t\t// completion handler\n\t\tvar self = this;\n\t\thttp.onload = function() {\n\t\t\tif (callback) callback.apply( self, [http.status, http.responseText, http.statusText] );\n\t\t\tWebcam.dispatch('uploadComplete', http.status, http.responseText, http.statusText);\n\t\t};\n\t\t\n\t\t// create a blob and decode our base64 to binary\n\t\tvar blob = new Blob( [ this.base64DecToArr(raw_image_data) ], {type: 'image/'+image_fmt} );\n\t\t\n\t\t// stuff into a form, so servers can easily receive it as a standard file upload\n\t\tvar form = new FormData();\n\t\tform.append( form_elem_name, blob, form_elem_name+\".\"+image_fmt.replace(/e/, '') );\n\t\t\n\t\t// send data to server\n\t\thttp.send(form);\n\t}\n\t\n};\n\nWebcam.init();\n\nif (typeof define === 'function' && define.amd) {\n\tdefine( function() { return Webcam; } );\n} \nelse if (typeof module === 'object' && module.exports) {\n\tmodule.exports = Webcam;\n} \nelse {\n\twindow.Webcam = Webcam;\n}\n\n}(window));\n"

/***/ }
/******/ ]);